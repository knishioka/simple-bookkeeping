# Resolve GitHub Issue

GitHub Issueの解決を自動化し、標準的な開発ワークフローを実行します。

## 使用方法

```
/resolve-gh-issue <issue-number>
```

## 説明

このコマンドは、Simple Bookkeepingプロジェクトの標準的なIssue駆動開発ワークフローを自動化します。一貫性のある品質の高い実装を保証し、手作業によるミスを削減します。

## ワークフローステップ

### 1. Issue分析と理解

- `gh issue view <issue-number>` でGitHub Issueを取得
- Issue内容、要件、受け入れ条件を分析
- Issueタイプを特定し、適切なブランチプレフィックスを決定
- 必要な変更の範囲と複雑さを理解

### 2. コードベース分析

- 現在の実装を理解するためコードベースを検索
- 関連するファイル、モジュール、コンポーネントを特定
- 既存のパターンと規約をレビュー
- ドキュメントと関連コードを分析
- 変更の影響範囲を特定

### 3. テスト駆動開発計画

- 実装前に失敗するテストを作成（該当する場合）
- 必要な機能を捉えるテストケースを定義
- 実装前にテスト構造を作成
- コードベースの既存のテストパターンに従う

### 4. 開発計画

- TodoWriteツールを使用して構造化された開発計画を作成
- 複雑なタスクを管理可能なステップに分解
- 依存関係に基づいてタスクの優先順位を決定
- 既存の規約に従った実装アプローチを計画

### 5. ブランチ作成とセットアップ

- 規約に従って適切な名前のブランチを作成:
  - `feature/<issue-num>-<short-description>` 新機能用
  - `fix/<issue-num>-<short-description>` バグ修正用
  - `doc/<issue-num>-<short-description>` ドキュメント用
  - `refactor/<issue-num>-<short-description>` リファクタリング用
  - `test/<issue-num>-<short-description>` テスト用
  - `chore/<issue-num>-<short-description>` メンテナンス用
- 最新のmainブランチから開始することを確認
- アップストリーム追跡でブランチをリモートにプッシュ

### 6. 実装

- 既存のコードパターンと規約に従う
- 変更を段階的に実装
- 明確なメッセージでアトミックなコミットを作成
- コミットメッセージでIssue番号を参照
- 実装をシンプルに保ち、過度なエンジニアリングを避ける
- TypeScriptの型安全性を維持

### 7. 品質保証チェック

必要なすべての品質チェックを順番に実行:

- `pnpm lint` - ESLintとPrettierチェック
- `pnpm typecheck` - TypeScriptの型チェック
- `pnpm test` - すべてのテストを実行
- `pnpm test:e2e` - E2Eテストを実行（該当する場合）
- `pnpm build` - ビルドが成功することを確認

### 8. コミット作成

- 明確で説明的なメッセージでアトミックなコミットを作成
- 既存のコミットメッセージ規約に従う:
  - `feat:` 新機能
  - `fix:` バグ修正
  - `docs:` ドキュメントのみの変更
  - `style:` コードの意味に影響しない変更
  - `refactor:` バグ修正や機能追加を含まないコード変更
  - `test:` テストの追加や修正
  - `chore:` ビルドプロセスやツールの変更
- コミットメッセージでIssue番号を参照
- pre-commitフックをバイパスするために `--no-verify` を使用しない

### 9. ドラフトPR作成

- `gh pr create --draft` を使用してドラフトPRを作成
- 適切なタイトル形式を使用:
  - `feat: [説明] (#issue-number)`
  - `fix: [説明] (#issue-number)`
  - `docs: [説明] (#issue-number)`
- 包括的なPR説明を含める:
  - 変更の概要
  - 元のIssueへのリンク
  - テスト計画と検証手順
  - 破壊的変更や考慮事項

### 10. CIモニタリングと解決

- PR作成後のGitHub Actionsステータスを監視
- すべてのCIチェックが完了するまで待機
- CIが失敗した場合:
  - 失敗ログを分析
  - ローカルで問題を修正
  - 品質チェックを再度実行
  - 同じブランチに修正をプッシュ
  - すべてのチェックが通過するまでCIを監視
- **自動的にreadyに変換しない**: CI通過後、ユーザーに確認を求める
- 以下の条件を満たした後のみ、`gh pr ready` でレビュー準備完了にする:
  - すべてのCIチェックが通過
  - ユーザーが明示的に続行を確認
- **必ずPR URLを最後に表示**: 最終出力としてPRリンクを表示

### 11. 最終検証

- 元のIssueのすべての受け入れ条件が満たされていることを確認
- すべてのテストがローカルとCIで通過することを確認
- ビルドが成功することを確認
- PR変更を最終的にレビュー
- TodoWriteタスクを完了としてマーク

## 前提条件

- `gh` CLIツールが設定され、認証されている
- すべての依存関係でローカル開発環境がセットアップされている
- 適切な権限でリポジトリにアクセスできる
- 必要なツールがすべてインストールされている（pnpm、node等）

## エラーハンドリング

ステップが失敗した場合:

1. ワークフローを即座に停止
2. エラーを明確に報告
3. 手動解決のガイダンスを提供
4. 問題が解決されるまで次のステップに進まない

## 品質基準

- すべてのコードはlinting、testing、型チェックを通過する必要がある
- 既存のコードパターンと規約に従う
- TypeScriptのany型を使用しない
- 絶対インポートを使用（`@/`エイリアス）
- 型エラーを無視しない、`// @ts-ignore` を使用しない
- すべてのpre-commitフックが通過することを確認
- 品質チェックをバイパスしない

## ブランチとPR規約

- ブランチ名は形式に従う: `<prefix>/<issue-num>-<short-description>`
- PRは最初にドラフトとして作成する
- PRタイトルはIssueタイプの規約に従う
- すべてのGitHub操作は `gh` コマンドを使用
- すべてのCIが通過し、ユーザーが確認した後のみreadyに変換
- 最終出力として常にPR URLを表示

## 既存ツールとの統合

- タスク追跡と計画にTodoWriteを使用
- プロジェクトのnpmスクリプトと統合
- CLAUDE.md開発標準に従う
- プロジェクトの品質ゲートと要件を尊重
- 既存のCI/CDパイプラインとの互換性を維持

## プロジェクト固有の考慮事項

### モノレポ構造

- 変更がどのワークスペースに影響するか確認
- 共有パッケージへの変更は全体への影響を考慮
- 適切なフィルターでコマンドを実行（例: `pnpm --filter @simple-bookkeeping/web test`）

### 環境変数

- 新しい環境変数を追加する場合は `.env.example` を更新
- `NEXT_PUBLIC_API_URL` は完全なパス（`/api/v1`を含む）を使用
- 機密情報は絶対にコミットしない

### データベース変更

- Prismaスキーマの変更後は必ずマイグレーションを作成
- `pnpm db:migrate` でマイグレーションを実行
- 必要に応じてシードデータを更新

### デプロイメント考慮事項

- Vercel（フロントエンド）とRender（API）の両方でビルドが成功することを確認
- 環境固有の設定を考慮

## 成功基準

コマンドは以下の条件を満たしたときに成功:

- [ ] Issueが完全に分析され理解されている
- [ ] 適切なブランチが作成されプッシュされている
- [ ] 必要なすべての変更が実装されている
- [ ] すべてのテストが通過（`pnpm test`）
- [ ] コードが適切にlintされている（`pnpm lint`）
- [ ] 型チェックが通過（`pnpm typecheck`）
- [ ] ビルドが成功（`pnpm build`）
- [ ] 適切な形式でドラフトPRが作成されている
- [ ] すべてのCIチェックが通過
- [ ] Issue要件が完全に満たされている
